// show action panel next to selected card
function showCardActions(side, idx)
{
    if (side !== 'player' || !playerTurn) return;
    
    // Don't show actions during setup phase
    if (turnIndicator.textContent.includes('Setup')) return;

    const slot = playerSlots[idx];
    if (!slot || slot.used) return;
    
    // Check for status effects that prevent actions
    if (slot.statusEffects) {
        const preventingEffects = slot.statusEffects.filter(effect => 
            effect.type === 'stun' || effect.type === 'sleep'
        );
        if (preventingEffects.length > 0) {
            const effectName = preventingEffects[0].type === 'stun' ? 'stunned' : 'sleeping';
            addLog('system', `${slot.card.name} is ${effectName} and cannot act!`);
            return;
        }
    }

    hideActionPanel();
    clearSelections();

    const slotEl = playerSlotsEl.children[idx];
    const cardEl = slotEl.querySelector('.card');
    if (!cardEl) return;

    cardEl.classList.add('selected');

    // Create action panel
    const panel = document.createElement('div');
    panel.className = 'card-action-panel';

    // Position it next to the card
    const rect = slotEl.getBoundingClientRect();
    panel.style.left = (rect.right + 10) + 'px';
    panel.style.top = rect.top + 'px';

    // Find opposite slot (computer slot at same index)
    const oppositeSlot = computerSlots[idx];
    const canAttack = oppositeSlot && oppositeSlot.hp > 0;

    // Create attack buttons for each attack the card has (SIMPLE VERSION THAT WORKS)
    slot.card.attacks.forEach((attack, attackIndex) => {
        const attackBtn = document.createElement('div');
        attackBtn.className = `btn ${!canAttack && attack.damage > 0 ? 'disabled' : ''}`;
        
        // Format button text with damage and effect info
        let buttonText = attack.name;
        if(attack.damage > 0) buttonText += ` (${attack.damage})`;
        if(attack.effect) buttonText += ` [${attack.effect.toUpperCase()}]`;
        
        attackBtn.textContent = buttonText;
        attackBtn.title = attack.description; // Tooltip with full description
        
        attackBtn.addEventListener('click', () => {
            if(canAttack || attack.damage === 0) {
                performUniqueAttack(idx, attackIndex);
            }
        });
        
        panel.appendChild(attackBtn);
    });

    // DEFEND button
    const defendBtn = document.createElement('div');
    defendBtn.className = 'btn';
    defendBtn.textContent = 'DEFEND';
    defendBtn.addEventListener('click', () => performDefend(idx));

    panel.appendChild(defendBtn);

    // Show info if can't attack
    if (!canAttack) {
        const noTargetMsg = document.createElement('div');
        noTargetMsg.style.cssText = `
            font-size: 8px;
            color: #aaa;
            text-align: center;
            margin-top: 4px;
        `;
        noTargetMsg.textContent = 'No opposite target';
        panel.appendChild(noTargetMsg);
    }

    document.body.appendChild(panel);
    currentActionPanel = panel;
    selected = { side: 'player', idx };
}// show action panel next to selected card
function showCardActions(side, idx)
{
    if (side !== 'player' || !playerTurn) return;
    
    // Don't show actions during setup phase
    if (turnIndicator.textContent.includes('Setup')) return;

    const slot = playerSlots[idx];
    if (!slot || slot.used) return;
    
    // Check for status effects that prevent actions
    if (slot.statusEffects) {
        const preventingEffects = slot.statusEffects.filter(effect => 
            effect.type === 'stun' || effect.type === 'sleep'
        );
        if (preventingEffects.length > 0) {
            const effectName = preventingEffects[0].type === 'stun' ? 'stunned' : 'sleeping';
            addLog('system', `${slot.card.name} is ${effectName} and cannot act!`);
            return;
        }
    }

    hideActionPanel();
    clearSelections();

    const slotEl = playerSlotsEl.children[idx];
    const cardEl = slotEl.querySelector('.card');
    if (!cardEl) return;

    cardEl.classList.add('selected');

    // Create action panel
    const panel = document.createElement('div');
    panel.className = 'card-action-panel';

    // Position it next to the card
    const rect = slotEl.getBoundingClientRect();
    panel.style.left = (rect.right + 10) + 'px';
    panel.style.top = rect.top + 'px';

    // Find opposite slot (computer slot at same index)
    const oppositeSlot = computerSlots[idx];
    const canAttack = oppositeSlot && oppositeSlot.hp > 0;

    // Create attack buttons for each attack the card has (SIMPLE VERSION THAT WORKS)
    slot.card.attacks.forEach((attack, attackIndex) => {
        const attackBtn = document.createElement('div');
        attackBtn.className = `btn ${!canAttack && attack.damage > 0 ? 'disabled' : ''}`;
        
        // Format button text with damage and effect info
        let buttonText = attack.name;
        if(attack.damage > 0) buttonText += ` (${attack.damage})`;
        if(attack.effect) buttonText += ` [${attack.effect.toUpperCase()}]`;
        
        attackBtn.textContent = buttonText;
        attackBtn.title = attack.description; // Tooltip with full description
        
        attackBtn.addEventListener('click', () => {
            if(canAttack || attack.damage === 0) {
                performUniqueAttack(idx, attackIndex);
            }
        });
        
        panel.appendChild(attackBtn);
    });

    // DEFEND button
    const defendBtn = document.createElement('div');
    defendBtn.className = 'btn';
    defendBtn.textContent = 'DEFEND';
    defendBtn.addEventListener('click', () => performDefend(idx));

    panel.appendChild(defendBtn);

    // Show info if can't attack
    if (!canAttack) {
        const noTargetMsg = document.createElement('div');
        noTargetMsg.style.cssText = `
            font-size: 8px;
            color: #aaa;
            text-align: center;
            margin-top: 4px;
        `;
        noTargetMsg.textContent = 'No opposite target';
        panel.appendChild(noTargetMsg);
    }

    document.body.appendChild(panel);
    currentActionPanel = panel;
    selected = { side: 'player', idx };
}// show action panel next to selected card
function showCardActions(side, idx)
{
    if (side !== 'player' || !playerTurn) return;
    
    // Don't show actions during setup phase
    if (turnIndicator.textContent.includes('Setup')) return;

    const slot = playerSlots[idx];
    if (!slot || slot.used) return;
    
    // Check for status effects that prevent actions
    if (slot.statusEffects) {
        const preventingEffects = slot.statusEffects.filter(effect => 
            effect.type === 'stun' || effect.type === 'sleep'
        );
        if (preventingEffects.length > 0) {
            const effectName = preventingEffects[0].type === 'stun' ? 'stunned' : 'sleeping';
            addLog('system', `${slot.card.name} is ${effectName} and cannot act!`);
            return;
        }
    }

    hideActionPanel();
    clearSelections();

    const slotEl = playerSlotsEl.children[idx];
    const cardEl = slotEl.querySelector('.card');
    if (!cardEl) return;

    cardEl.classList.add('selected');

    // Create action panel
    const panel = document.createElement('div');
    panel.className = 'card-action-panel';

    // Position it next to the card
    const rect = slotEl.getBoundingClientRect();
    panel.style.left = (rect.right + 10) + 'px';
    panel.style.top = rect.top + 'px';

    // Find opposite slot (computer slot at same index)
    const oppositeSlot = computerSlots[idx];
    const canAttack = oppositeSlot && oppositeSlot.hp > 0;

    // Create attack buttons for each attack the card has (SIMPLE VERSION THAT WORKS)
    slot.card.attacks.forEach((attack, attackIndex) => {
        const attackBtn = document.createElement('div');
        attackBtn.className = `btn ${!canAttack && attack.damage > 0 ? 'disabled' : ''}`;
        
        // Format button text with damage and effect info
        let buttonText = attack.name;
        if(attack.damage > 0) buttonText += ` (${attack.damage})`;
        if(attack.effect) buttonText += ` [${attack.effect.toUpperCase()}]`;
        
        attackBtn.textContent = buttonText;
        attackBtn.title = attack.description; // Tooltip with full description
        
        attackBtn.addEventListener('click', () => {
            if(canAttack || attack.damage === 0) {
                performUniqueAttack(idx, attackIndex);
            }
        });
        
        panel.appendChild(attackBtn);
    });

    // DEFEND button
    const defendBtn = document.createElement('div');
    defendBtn.className = 'btn';
    defendBtn.textContent = 'DEFEND';
    defendBtn.addEventListener('click', () => performDefend(idx));

    panel.appendChild(defendBtn);

    // Show info if can't attack
    if (!canAttack) {
        const noTargetMsg = document.createElement('div');
        noTargetMsg.style.cssText = `
            font-size: 8px;
            color: #aaa;
            text-align: center;
            margin-top: 4px;
        `;
        noTargetMsg.textContent = 'No opposite target';
        panel.appendChild(noTargetMsg);
    }

    document.body.appendChild(panel);
    currentActionPanel = panel;
    selected = { side: 'player', idx };
}
