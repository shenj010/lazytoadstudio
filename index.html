<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Toad Battle Arena</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=DotGothic16&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#2D1B69; --bg2:#11998E; --bg3:#38EF7D;
    --panel:#0f0f0f; --accent:#38EF7D; --danger:#ff4444;
  }
  html,body{height:100%;margin:0;font-family:'Press Start 2P','DotGothic16',monospace;background:linear-gradient(135deg,var(--bg1),var(--bg2),var(--bg3));color:#fff;overflow:hidden}
  .wrap{position:relative;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:14px;box-sizing:border-box}
  .header{width:100%;text-align:center;margin-bottom:8px;z-index:5}
  .title{color:var(--accent);font-size:18px;text-shadow:0 0 6px rgba(0,0,0,.6)}
  .arena{position:relative;flex:1;width:100%;max-width:1100px;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:space-between;padding:12px;box-sizing:border-box}
  
  .area{width:100%;display:flex;align-items:center;justify-content:space-between;background:rgba(0,0,0,0.45);border:3px solid #fff;padding:12px;border-radius:8px}
  .player-info{display:flex;flex-direction:column;align-items:center;min-width:160px}
  .name{color:var(--accent);font-size:12px;margin-bottom:6px}
  .hp-bar{width:160px;height:20px;background:#111;border:2px solid #fff;border-radius:6px;overflow:hidden;display:flex;align-items:center;justify-content:center}
  .hp-segments{display:flex;width:92%;gap:2px}
  .seg{flex:1;height:14px;background:#fff;border-radius:2px;opacity:1;box-sizing:border-box;position:relative}
  .seg.half::after{content:'';position:absolute;left:0;top:0;bottom:0;width:50%;background:#111}
  .hand{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;align-items:center;flex:1;min-height:140px}
  
  .slots{display:flex;gap:10px;align-items:center;justify-content:center}
  .slot{width:90px;height:130px;border:2px dashed rgba(255,255,255,0.25);border-radius:8px;background:rgba(0,0,0,0.25);display:flex;align-items:center;justify-content:center;position:relative}
  .slot.occupied{border-style:solid}
  .slot .card{width:86px;height:120px;border:3px solid #fff;border-radius:6px;background:#222;overflow:hidden;cursor:pointer;display:flex;flex-direction:column;transition:opacity 0.3s ease}
  .card img{width:100%;height:72%;object-fit:cover;display:block}
  .card .stats{height:28%;background:rgba(0,0,0,0.9);padding:4px;box-sizing:border-box;font-size:10px;text-align:center}
  .card.selected{outline:3px solid var(--accent);transform:translateY(-6px)}
  .card.used{opacity:0.4;filter:grayscale(0.7)}
  .card.used::after{content:'USED';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:#fff;padding:2px 6px;font-size:8px;border-radius:3px;pointer-events:none}
  
  /* STATUS EFFECT INDICATORS */
  .status-effects-container {
    position: absolute;
    top: -2px;
    right: -2px;
    display: flex;
    flex-direction: column;
    gap: 2px;
    z-index: 20;
  }
  
  .status-effect {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    color: white;
    position: relative;
    border: 1px solid white;
    box-shadow: 0 0 3px rgba(0,0,0,0.5);
  }
  
  .status-effect.poison {
    background-color: #8B4513;
    animation: pulse-poison 2s infinite;
  }
  
  .status-effect.poison::before {
    content: "‚ò†Ô∏è";
    font-size: 10px;
  }
  
  .status-effect.stun {
    background-color: #FFD700;
    color: #000;
  }
  
  .status-effect.stun::before {
    content: "‚ö°";
    font-size: 12px;
  }
  
  .status-effect.sleep {
    background-color: #4169E1;
  }
  
  .status-effect.sleep::before {
    content: "üí§";
    font-size: 10px;
  }
  
  .status-effect.weaken {
    background-color: #8A2BE2;
  }
  
  .status-effect.weaken::before {
    content: "‚¨áÔ∏è";
    font-size: 10px;
  }
  
  .status-turns {
    position: absolute;
    bottom: -3px;
    right: -3px;
    background: rgba(0,0,0,0.8);
    border-radius: 50%;
    width: 12px;
    height: 12px;
    font-size: 7px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid white;
    color: white;
  }
  
  .sleep-zzz {
    position: absolute;
    top: 5px;
    right: 8px;
    color: #4169E1;
    font-size: 14px;
    font-weight: bold;
    animation: float-zzz 2s ease-in-out infinite;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    pointer-events: none;
  }
  
  .sleep-zzz:nth-child(2) {
    right: 15px;
    top: 8px;
    font-size: 12px;
    animation-delay: 0.5s;
  }
  
  .sleep-zzz:nth-child(3) {
    right: 20px;
    top: 12px;
    font-size: 10px;
    animation-delay: 1s;
  }
  
  @keyframes float-zzz {
    0% { transform: translateY(0) scale(0.8); opacity: 0.3; }
    50% { transform: translateY(-10px) scale(1.2); opacity: 1; }
    100% { transform: translateY(-15px) scale(0.8); opacity: 0; }
  }
  
  @keyframes pulse-poison {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  /* FIXED ACTION PANEL STYLING */
  .card-action-panel{
    position:fixed !important;
    z-index:1000 !important;
    background:rgba(0,0,0,0.95);
    border:3px solid var(--accent);
    border-radius:8px;
    padding:12px;
    display:flex;
    gap:8px;
    flex-direction:column;
    min-width:140px;
    box-shadow:0 0 20px rgba(0,0,0,0.8);
  }
  .card-action-panel .btn{
    background:#fff;
    color:#000;
    border:2px solid #000;
    padding:8px 12px;
    font-family:'Press Start 2P',monospace;
    font-size:10px;
    cursor:pointer;
    text-align:center;
    border-radius:4px;
    transition:all 0.2s ease;
  }
  .card-action-panel .btn:hover{
    background:var(--accent);
    color:#000;
    transform:scale(1.05);
  }
  .card-action-panel .btn:active{transform:scale(.95)}
  .card-action-panel .btn.disabled{
    background:#666;
    color:#333;
    cursor:not-allowed;
  }
  
  .turn-panel{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;display:flex;gap:12px;z-index:50}
  .btn{background:#fff;color:#000;border:2px solid #000;padding:10px 16px;font-family:'Press Start 2P',monospace;font-size:11px;cursor:pointer}
  .btn:active{transform:scale(.98)}
  .btn.disabled{background:#666;color:#333;cursor:not-allowed}
  
  .turn-indicator{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);border:2px solid var(--accent);padding:8px 16px;border-radius:6px;font-size:12px;z-index:60}
  
  .attacking-forward{animation:attackForward 1000ms ease-in-out forwards;z-index:1000;}
  @keyframes attackForward{
    0%{transform:translateY(0) scale(1) rotateZ(0deg)}
    25%{transform:translateY(80px) scale(1.2) rotateZ(5deg)}
    50%{transform:translateY(160px) scale(1.3) rotateZ(-3deg)}
    75%{transform:translateY(200px) scale(1.1) rotateZ(2deg)}
    100%{transform:translateY(0) scale(1) rotateZ(0deg)}
  }
  
  .attacking-backward{animation:attackBackward 1000ms ease-in-out forwards;z-index:1000;}
  @keyframes attackBackward{
    0%{transform:translateY(0) scale(1) rotateZ(0deg)}
    25%{transform:translateY(-80px) scale(1.2) rotateZ(-5deg)}
    50%{transform:translateY(-160px) scale(1.3) rotateZ(3deg)}
    75%{transform:translateY(-200px) scale(1.1) rotateZ(-2deg)}
    100%{transform:translateY(0) scale(1) rotateZ(0deg)}
  }
  
  .flying-attack{animation:flyToTarget 800ms ease-in-out forwards;z-index:2000;position:absolute;}
  @keyframes flyToTarget{
    0%{transform:translate(0, 0) scale(1) rotateZ(0deg);opacity:1;}
    50%{transform:translate(var(--target-x), var(--target-y)) scale(1.2) rotateZ(180deg);opacity:0.8;}
    100%{transform:translate(var(--target-x), var(--target-y)) scale(0.8) rotateZ(360deg);opacity:0;}
  }
  
  .defending-anim{animation:defendPulse 600ms ease-in-out forwards}
  @keyframes defendPulse{
    0%{transform:scale(1);box-shadow:0 0 0 rgba(56,239,125,0.8)}
    50%{transform:scale(1.08);box-shadow:0 0 20px rgba(56,239,125,0.8)}
    100%{transform:scale(1);box-shadow:0 0 10px rgba(56,239,125,0.6)}
  }
  
  .dmg-pop{position:absolute;font-size:16px;font-weight:700;color:#ff4444;pointer-events:none;animation:damageFloat 1000ms ease-out forwards;z-index:200;text-shadow:2px 2px 0 #000}
  @keyframes damageFloat{
    0%{transform:translateY(0) translateX(-50%) scale(0.8);opacity:0}
    20%{transform:translateY(-10px) translateX(-50%) scale(1.2);opacity:1}
    60%{transform:translateY(-40px) translateX(-50%) scale(1);opacity:1}
    100%{transform:translateY(-70px) translateX(-50%) scale(0.8);opacity:0}
  }
  
  .hit{animation:hitShake 400ms ease-out forwards}
  @keyframes hitShake{
    0%{transform:translateX(0)}
    10%{transform:translateX(-8px) rotateZ(-2deg)}
    20%{transform:translateX(6px) rotateZ(1deg)}
    30%{transform:translateX(-4px) rotateZ(-1deg)}
    40%{transform:translateX(3px) rotateZ(0.5deg)}
    50%{transform:translateX(-2px) rotateZ(-0.5deg)}
    60%{transform:translateX(1px) rotateZ(0.2deg)}
    100%{transform:translateX(0) rotateZ(0deg)}
  }
  
  .flash{animation:flashHit 300ms ease-out forwards}
  @keyframes flashHit{
    0%{filter:brightness(1) contrast(1)}
    25%{filter:brightness(1.8) contrast(1.3) saturate(0)}
    50%{filter:brightness(1.5) contrast(1.2) saturate(0.2)}
    75%{filter:brightness(1.3) contrast(1.1) saturate(0.6)}
    100%{filter:brightness(1) contrast(1) saturate(1)}
  }
  
  .die{animation:dieFade 600ms ease forwards}
  @keyframes dieFade{0%{opacity:1;transform:scale(1) rotateZ(0deg)}100%{opacity:0;transform:scale(0.3) rotateZ(15deg)}}
  
  .log{position:fixed;right:14px;top:70px;width:250px;height:340px;background:rgba(0,0,0,.6);border:2px solid #fff;padding:8px;overflow:auto;font-size:11px;z-index:60}
  .log .entry{margin-bottom:6px}
  .log .player{color:var(--accent)}
  .log .computer{color:var(--danger)}
  
  @media (max-width:900px){
    .area{flex-direction:column;gap:8px}
    .player-info{min-width:140px}
    .slots{flex-wrap:wrap}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="header"><div class="title">TOAD BATTLE ARENA</div></div>
    
    <div class="turn-indicator" id="turnIndicator">Player Turn</div>

    <div class="arena" id="arena">
      <!-- COMPUTER AREA -->
      <div class="area" id="computerArea">
        <div class="player-info">
          <div class="name">Computer</div>
          <div class="hp-bar" title="Computer total HP">
            <div class="hp-segments" id="computerGlobalHP"></div>
          </div>
          <div style="height:6px"></div>
        </div>

        <div class="slots" id="computerSlots">
          <!-- 5 slots -->
        </div>

        <div class="hand" id="computerHand">
          <!-- computer reserve cards (small) -->
        </div>
      </div>

      <!-- PLAYER AREA -->
      <div class="area" id="playerArea">
        <div class="player-info">
          <div class="name">Player</div>
          <div class="hp-bar" title="Player total HP">
            <div class="hp-segments" id="playerGlobalHP"></div>
          </div>
          <div style="height:6px"></div>
        </div>

        <div class="slots" id="playerSlots">
          <!-- 5 slots -->
        </div>

        <div class="hand" id="playerHand" style="margin-left:12px">
          <!-- player hand cards (click to place on slots) -->
        </div>
      </div>
    </div>

    <!-- turn control panel -->
    <div class="turn-panel" id="turnPanel">
      <div class="btn" id="endTurnBtn">END TURN</div>
    </div>

    <div class="log" id="battleLog"><div class="entry system">Battle ready ‚Äì place cards to begin.</div></div>
  </div>

<script>
(function(){
  // config
  const MAX_SLOTS = 5;
  const MAX_HP = 80; 
  const SEGMENTS = 8;

  // Enhanced card pool with unique attacks and abilities
  const cardPool = [
    { 
      src: "images/cards/the stranger card format.jpg", 
      name: "The Stranger",
      hp: 80,
      attacks: [
        { name: "Hidden Strike", damage: 10, type: "physical", effect: "stun", duration: 1, description: "Fast slice hits your opponent for 10 points. Stun opponent for one turn." }
      ]
    },
    { 
      src: "images/cards/horny toad card format.jpg", 
      name: "Horny Toad",
      hp: 80,
      attacks: [
        { name: "Piercing Strike", damage: 20, type: "physical", description: "A devastating, surgical strike deals 20 damage to your opponent." }
      ]
    },
    { 
      src: "images/cards/hypno toad card format.jpg", 
      name: "Hypno Toad",
      hp: 80,
      attacks: [
        { name: "Hypnotize", damage: 0, type: "mental", effect: "sleep", duration: 2, description: "Send the opponent to sleep for 2 turns." },
        { name: "Poison Dart", damage: 5, type: "poison", effect: "poison", duration: 5, description: "Poisons your opponent for 5 turns, 5 damage per turn." }
      ]
    },
    { 
      src: "images/cards/sumo toad card format.jpg", 
      name: "Sumo Toad",
      hp: 80,
      attacks: [
        { name: "Oshidashi", damage: 10, type: "physical", effect: "weaken", duration: 1, description: "Use sheer force to damage your enemy for 10 and reduce their next attack by 10." }
      ]
    },
    { 
      src: "images/cards/mad toad card format.jpg", 
      name: "Mad Toad",
      hp: 80,
      attacks: [
        { name: "Flasher", damage: 0, type: "mental", effect: "stun", duration: 1, description: "Stun your opponent for one turn." },
        { name: "Bubble Slam", damage: 10, type: "physical", description: "A rear-end first slam hitting opponent for ten points." }
      ]
    }
  ];

  // state
  let playerHand = [];      
  let computerReserve = [];
  let playerSlots = new Array(MAX_SLOTS).fill(null); 
  let computerSlots = new Array(MAX_SLOTS).fill(null);
  let selected = null; 
  let playerTurn = true;
  let currentActionPanel = null; 

  // elements
  const playerHandEl = document.getElementById('playerHand');
  const computerHandEl = document.getElementById('computerHand');
  const playerSlotsEl = document.getElementById('playerSlots');
  const computerSlotsEl = document.getElementById('computerSlots');
  const logEl = document.getElementById('battleLog');
  const turnPanel = document.getElementById('turnPanel');
  const endTurnBtn = document.getElementById('endTurnBtn');
  const playerGlobalHP = document.getElementById('playerGlobalHP');
  const computerGlobalHP = document.getElementById('computerGlobalHP');
  const turnIndicator = document.getElementById('turnIndicator');

  function makeSlotsUI(){
    playerSlotsEl.innerHTML = '';
    computerSlotsEl.innerHTML = '';
    for(let i=0;i<MAX_SLOTS;i++){
      const ps = document.createElement('div'); ps.className='slot'; ps.dataset.i=i; ps.dataset.side='player';
      ps.addEventListener('click', ()=>onSlotClick('player', i));
      playerSlotsEl.appendChild(ps);
      const cs = document.createElement('div'); cs.className='slot'; cs.dataset.i=i; cs.dataset.side='computer';
      cs.addEventListener('click', ()=>onSlotClick('computer', i));
      computerSlotsEl.appendChild(cs);
    }
  }

  function loadPlayerInventory(){
    let stored = [];
    try {
      stored = JSON.parse(localStorage.getItem('collectedCards')) || [];
    } catch(e){ stored = []; }
    if(!stored || stored.length === 0) stored = [...cardPool];
    playerHand = stored.slice(0,10);
    console.log("Player hand loaded:", playerHand.length, "cards");
  }

  function buildComputerReserve(){
    const playerCardCount = playerHand.length;
    const cp = [];
    for(let i=0;i<playerCardCount;i++){
      cp.push(cardPool[Math.floor(Math.random()*cardPool.length)]);
    }
    computerReserve = cp;
    console.log("Computer reserve built:", computerReserve.length, "cards");
  }

  function renderHand(){
    playerHandEl.innerHTML = '';
    playerHand.forEach((card, idx) => {
      const c = createHandCardEl(card, idx);
      playerHandEl.appendChild(c);
    });
    
    computerHandEl.innerHTML = '';
    const remainingCards = computerReserve.length - computerSlots.filter(s => s).length;
    for(let i = 0; i < remainingCards; i++){
      const c = createCardBackEl();
      computerHandEl.appendChild(c);
    }
  }

  function createCardBackEl(){
    const el = document.createElement('div'); 
    el.className='card'; 
    el.style.width='86px'; 
    el.style.height='120px';
    el.style.cursor='default';
    
    const cardBack = document.createElement('div');
    cardBack.style.width = '100%';
    cardBack.style.height = '100%';
    cardBack.style.background = 'linear-gradient(45deg, #333, #666)';
    cardBack.style.display = 'flex';
    cardBack.style.alignItems = 'center';
    cardBack.style.justifyContent = 'center';
    cardBack.style.color = '#fff';
    cardBack.style.fontSize = '12px';
    cardBack.textContent = 'TOAD';
    
    el.appendChild(cardBack);
    
    const wrap = document.createElement('div'); 
    wrap.style.width='86px'; 
    wrap.style.height='120px';
    wrap.appendChild(el);
    return wrap;
  }

  function createHandCardEl(card, idx){
    const el = document.createElement('div'); 
    el.className='card'; 
    el.style.width='86px'; 
    el.style.height='120px';
    el.addEventListener('click', ()=>onHandClick(idx));
    
    const img = document.createElement('img'); 
    img.src=card.src; 
    img.alt=card.name;
    
    img.onerror = function() {
      const placeholder = document.createElement('div');
      placeholder.style.width = '100%';
      placeholder.style.height = '72%';
      placeholder.style.background = 'linear-gradient(45deg, #2D1B69, #11998E)';
      placeholder.style.display = 'flex';
      placeholder.style.alignItems = 'center';
      placeholder.style.justifyContent = 'center';
      placeholder.style.color = '#fff';
      placeholder.style.fontSize = '10px';
      placeholder.style.textAlign = 'center';
      placeholder.textContent = card.name;
      this.parentNode.replaceChild(placeholder, this);
    };
    
    const stats = document.createElement('div'); 
    stats.className='stats'; 
    stats.innerHTML = `<div style="font-size:10px">${card.name}</div><div style="font-size:10px">HP:${MAX_HP}</div>`;
    
    el.appendChild(img); 
    el.appendChild(stats);
    
    const wrap = document.createElement('div'); 
    wrap.style.width='86px'; 
    wrap.style.height='120px';
    wrap.appendChild(el);
    return wrap;
  }

  function onSlotClick(side, idx){
    if(side === 'player'){
      if(selected && selected.type==='hand'){
        if(playerSlots[idx] === null){
          const card = playerHand.splice(selected.index,1)[0];
          playerSlots[idx] = { card, hp: MAX_HP, defending:false, used:false, statusEffects: [] };
          selected = null;
          renderAll();
          addLog('system', `Placed ${card.name} in player slot ${idx+1}`);
          checkBattleStart();
        }
      } else {
        if(playerSlots[idx] && playerTurn){
          hideActionPanel();
          showCardActions('player', idx);
        }
      }
    } else {
      if(computerSlots[idx]) {
        clearSelections();
        const slotEl = computerSlotsEl.children[idx];
        if(slotEl && slotEl.firstChild) slotEl.firstChild.classList.add('selected');
      }
    }
  }

  function onHandClick(index){
    hideActionPanel();
    clearSelections();
    selected = { type:'hand', index };
    document.querySelectorAll('#playerHand .card').forEach((c,i)=>{
      if(i===index) c.classList.add('selected'); else c.classList.remove('selected');
    });
  }

  // FIXED: Better showCardActions function
  function showCardActions(side, idx){
    console.log("showCardActions called:", side, idx, "playerTurn:", playerTurn);
    
    if(side !== 'player' || !playerTurn) return;
    
    const slot = playerSlots[idx];
    if(!slot) {
      console.log("No slot found at index:", idx);
      return;
    }
    
    if(slot.used) {
      console.log("Card already used this turn");
      addLog('system', `${slot.card.name} already acted this turn`);
      return;
    }

    // Check status effects
    if(hasStatusEffect(slot, 'stun') || hasStatusEffect(slot, 'sleep')) {
      addLog('system', `${slot.card.name} cannot act due to status effect!`);
      return;
    }

    hideActionPanel();
    clearSelections();

    const slotEl = playerSlotsEl.children[idx];
    const cardEl = slotEl.querySelector('.card');
    if(!cardEl) return;

    cardEl.classList.add('selected');
    
    // Create action panel with better positioning
    const panel = document.createElement('div');
    panel.className = 'card-action-panel';
    
    // Calculate safe position
    const rect = slotEl.getBoundingClientRect();
    const panelWidth = 150;
    const panelHeight = 200;
    
    let left = rect.right + 10;
    let top = rect.top;
    
    // Adjust if panel would go off screen
    if (left + panelWidth > window.innerWidth) {
      left = rect.left - panelWidth - 10;
    }
    if (top + panelHeight > window.innerHeight) {
      top = window.innerHeight - panelHeight - 10;
    }
    if (top < 10) top = 10;
    if (left < 10) left = 10;
    
    panel.style.left = left + 'px';
    panel.style.top = top + 'px';

    const oppositeSlot = computerSlots[idx];
    const canAttack = oppositeSlot && oppositeSlot.hp > 0;

    console.log("Creating buttons for card:", slot.card.name, "canAttack:", canAttack);

    // Create attack buttons for each attack
    slot.card.attacks.forEach((attack, attackIndex) => {
      const attackBtn = document.createElement('div');
      attackBtn.className = `btn ${!canAttack && attack.damage > 0 ? 'disabled' : ''}`;
      
      let buttonText = attack.name;
      if(attack.damage > 0) buttonText += ` (${attack.damage})`;
      if(attack.effect) buttonText += ` [${attack.effect.toUpperCase()}]`;
      
      attackBtn.textContent = buttonText;
      attackBtn.title = attack.description;
      
      attackBtn.addEventListener('click', (e)=> {
        e.stopPropagation();
        console.log("Attack clicked:", attack.name);
        if(canAttack || attack.damage === 0) {
          performUniqueAttack(idx, attackIndex);
        }
      });
      
      panel.appendChild(attackBtn);
    });

    // Defend button
    const defendBtn = document.createElement('div');
    defendBtn.className = 'btn';
    defendBtn.textContent = 'Defend';
    defendBtn.addEventListener('click', (e)=> {
      e.stopPropagation();
      console.log("Defend clicked");
      performDefend(idx);
    });

    panel.appendChild(defendBtn);

    // Close button
    const closeBtn = document.createElement('div');
    closeBtn.className = 'btn';
    closeBtn.textContent = 'Close';
    closeBtn.style.background = '#ff6666';
    closeBtn.addEventListener('click', (e)=> {
      e.stopPropagation();
      hideActionPanel();
      clearSelections();
    });
    panel.appendChild(closeBtn);

    if(!canAttack) {
      const noTargetMsg = document.createElement('div');
      noTargetMsg.style.fontSize = '8px';
      noTargetMsg.style.color = '#aaa';
      noTargetMsg.style.textAlign = 'center';
      noTargetMsg.style.marginTop = '4px';
      noTargetMsg.textContent = 'No opposite target for attacks';
      panel.appendChild(noTargetMsg);
    }

    document.body.appendChild(panel);
    currentActionPanel = panel;
    selected = { side: 'player', idx };
    
    console.log("Action panel created and added");
  }

  function hideActionPanel(){
    if(currentActionPanel){
      currentActionPanel.remove();
      currentActionPanel = null;
    }
  }

  function clearSelections(){
    document.querySelectorAll('.card.selected').forEach(c=>c.classList.remove('selected'));
    selected = null;
  }

  function performUniqueAttack(attackerIdx, attackIndex){
    const attacker = playerSlots[attackerIdx];
    const targetIdx = attackerIdx;
    const target = computerSlots[targetIdx];
    
    if(!attacker || !target || attacker.used) return;

    const attack = attacker.card.attacks[attackIndex];
    if(!attack) return;

    attacker.used = true;
    
    const attackerSlotEl = playerSlotsEl.children[attackerIdx];
    const targetSlotEl = computerSlotsEl.children[targetIdx];
    const attackerCardEl = attackerSlotEl.querySelector('.card');
    const targetCardEl = targetSlotEl.querySelector('.card');
    
    let finalDmg = attack.damage;
    if(target.defending && finalDmg > 0){
      finalDmg = Math.ceil(finalDmg/2);
      target.defending = false;
      addLog('system', `${target.card.name} defended ‚Äì reduced damage!`);
    }

    if(attackerCardEl && targetCardEl && finalDmg > 0) {
      createFlyingProjectile(attackerCardEl, targetCardEl, (damageToApply) => {
        showDamagePopup(targetSlotEl, damageToApply, '#ff4444');
        
        targetCardEl.classList.add('hit', 'flash');
        setTimeout(()=>{
          targetCardEl.classList.remove('hit', 'flash');
        }, 400);
        
        target.hp = Math.max(0, target.hp - damageToApply);
        
        addLog('player', `${attacker.card.name} uses ${attack.name} on ${target.card.name} for ${damageToApply} damage`);
        
        applyStatusEffect(target, attack.effect, attack.duration, attacker.card.name);
        
        if(target.hp <= 0){
          setTimeout(() => {
            targetCardEl.classList.add('die');
            setTimeout(()=>{
              computerSlots[targetIdx] = null;
              renderAll();
              checkBattleOver();
            }, 600);
          }, 200);
        } else {
          updateSlotUI('computer', targetIdx);
          checkBattleOver();
        }
      }, finalDmg);
    } else {
      addLog('player', `${attacker.card.name} uses ${attack.name} on ${target.card.name}`);
      applyStatusEffect(target, attack.effect, attack.duration, attacker.card.name);
      
      if(attack.effect === 'poison' && attack.damage > 0) {
        setTimeout(() => {
          showDamagePopup(targetSlotEl, attack.damage, '#8B4513');
          target.hp = Math.max(0, target.hp - attack.damage);
          addLog('system', `${target.card.name} takes ${attack.damage} poison damage`);
          
          if(target.hp <= 0){
            setTimeout(() => {
              targetCardEl.classList.add('die');
              setTimeout(()=>{
                computerSlots[targetIdx] = null;
                renderAll();
                checkBattleOver();
              }, 600);
            }, 200);
          } else {
            updateSlotUI('computer', targetIdx);
            checkBattleOver();
          }
        }, 500);
      } else {
        checkBattleOver();
      }
    }

    hideActionPanel();
    renderAll();
  }

  function performDefend(slotIdx){
    const slot = playerSlots[slotIdx];
    if(!slot || slot.used) return;

    slot.used = true;
    slot.defending = true;
    
    const slotEl = playerSlotsEl.children[slotIdx];
    const cardEl = slotEl.querySelector('.card');
    if(cardEl){
      cardEl.classList.add('defending-anim');
      setTimeout(()=>cardEl.classList.remove('defending-anim'), 600);
    }
    
    addLog('player', `${slot.card.name} takes a defensive stance`);
    
    hideActionPanel();
    renderAll();
  }

  function computerTurn(){
    if(turnIndicator.textContent.includes('Setup')) return;
    
    turnIndicator.textContent = 'Computer Turn';
    endTurnBtn.classList.add('disabled');
    
    addLog('system', 'Computer is thinking...');
    
    setTimeout(()=>{
      processStatusEffects('computer');
      
      computerSlots.forEach(slot => {
        if(slot) {
          slot.used = false;
        }
      });

      performComputerActions();
    }, 800);
  }

  function performComputerActions(){
    const shouldPlaceCard = Math.random() < 0.4 && computerSlots.filter(s => s).length < 4;
    if(shouldPlaceCard && computerPlaceCard()){
      setTimeout(()=> performComputerActions(), 1000);
      return;
    }
    
    const activeSlots = computerSlots.map((slot, idx) => 
      slot && slot.hp > 0 && !slot.used && 
      !hasStatusEffect(slot, 'stun') && !hasStatusEffect(slot, 'sleep') ? idx : -1
    ).filter(idx => idx !== -1);

    if(activeSlots.length === 0){
      setTimeout(()=>endComputerTurn(), 800);
      return;
    }

    const slotIdx = activeSlots[Math.floor(Math.random() * activeSlots.length)];
    const slot = computerSlots[slotIdx];
    
    const targetSlot = playerSlots[slotIdx];
    const canAttack = targetSlot && targetSlot.hp > 0;
    
    let action;
    if(!canAttack){
      action = 'defend';
    } else {
      const isThreated = targetSlot && targetSlot.hp > 0;
      const shouldAttack = Math.random() > (isThreated ? 0.2 : 0.4);
      action = shouldAttack ? 'attack' : 'defend';
    }
    
    if(action === 'attack' && canAttack){
      const damage = Math.random() > 0.6 ? 10 : 5;
      performComputerAttack(slotIdx, damage);
    } else {
      performComputerDefend(slotIdx);
    }

    setTimeout(()=> {
      const remainingActive = computerSlots.filter(slot => 
        slot && slot.hp > 0 && !slot.used && 
        !hasStatusEffect(slot, 'stun') && !hasStatusEffect(slot, 'sleep')
      );
      if(remainingActive.length > 0) {
        performComputerActions();
      } else {
        endComputerTurn();
      }
    }, 1500);
  }

  function performComputerAttack(attackerIdx, damage){
    const attacker = computerSlots[attackerIdx];
    const target = playerSlots[attackerIdx];
    
    if(!attacker || !target) return;

    attacker.used = true;

    const attackerSlotEl = computerSlotsEl.children[attackerIdx];
    const targetSlotEl = playerSlotsEl.children[attackerIdx];
    const attackerCardEl = attackerSlotEl.querySelector('.card');
    const targetCardEl = targetSlotEl.querySelector('.card');
    
    let finalDmg = damage;
    if(target.defending){
      finalDmg = Math.ceil(finalDmg/2);
      target.defending = false;
      addLog('system', `${target.card.name} defended ‚Äì reduced damage!`);
    }

    if(attackerCardEl && targetCardEl) {
      createFlyingProjectile(attackerCardEl, targetCardEl, (damageToApply) => {
        showDamagePopup(targetSlotEl, damageToApply, '#ff4444');
        
        targetCardEl.classList.add('hit', 'flash');
        setTimeout(()=>{
          targetCardEl.classList.remove('hit', 'flash');
        }, 400);
        
        target.hp = Math.max(0, target.hp - damageToApply);
        
        addLog('computer', `${attacker.card.name} hits ${target.card.name} for ${damageToApply} damage`);
        
        if(target.hp <= 0){
          setTimeout(() => {
            targetCardEl.classList.add('die');
            setTimeout(()=>{
              playerSlots[attackerIdx] = null;
              renderAll();
              checkBattleOver();
            }, 600);
          }, 200);
        } else {
          updateSlotUI('player', attackerIdx);
          checkBattleOver();
        }
      }, finalDmg);
    } else {
      setTimeout(() => {
        showDamagePopup(targetSlotEl, finalDmg, '#ff4444');
        target.hp = Math.max(0, target.hp - finalDmg);
        addLog('computer', `${attacker.card.name} hits ${target.card.name} for ${finalDmg} damage`);
        if(target.hp <= 0){
          playerSlots[attackerIdx] = null;
          renderAll();
          checkBattleOver();
        } else {
          updateSlotUI('player', attackerIdx);
          checkBattleOver();
        }
      }, 300);
    }

    renderAll();
  }

  function performComputerDefend(slotIdx){
    const slot = computerSlots[slotIdx];
    if(!slot) return;

    slot.used = true;
    slot.defending = true;
    
    const slotEl = computerSlotsEl.children[slotIdx];
    const cardEl = slotEl.querySelector('.card');
    if(cardEl){
      cardEl.classList.add('defending-anim');
      setTimeout(()=>cardEl.classList.remove('defending-anim'), 600);
    }
    
    addLog('computer', `${slot.card.name} takes a defensive stance`);
    renderAll();
  }

  function endComputerTurn(){
    playerTurn = true;
    turnIndicator.textContent = 'Player Turn';
    endTurnBtn.classList.remove('disabled');
    
    processStatusEffects('player');
    
    playerSlots.forEach(slot => {
      if(slot) slot.used = false;
    });
    
    addLog('system', 'Player turn begins');
    renderAll();
  }

  function showDamagePopup(container, damage, color){
    const popup = document.createElement('div'); 
    popup.className='dmg-pop'; 
    popup.style.color = color || '#ff4444'; 
    popup.textContent = `-${damage}`;
    popup.style.left = '50%'; 
    popup.style.top = '10%';
    container.style.position = 'relative';
    container.appendChild(popup);
    setTimeout(()=> popup.remove(), 1000);
  }

  function applyStatusEffect(target, effect, duration, attackerName) {
    if(!effect || !duration) return;
    
    if(!target.statusEffects) target.statusEffects = [];
    
    const existingEffect = target.statusEffects.find(e => e.type === effect);
    if (existingEffect) {
      existingEffect.turnsRemaining = Math.max(existingEffect.turnsRemaining, duration);
      return;
    }
    
    const statusEffect = {
      type: effect,
      duration: duration,
      attacker: attackerName,
      turnsRemaining: duration
    };
    
    target.statusEffects.push(statusEffect);
    
    const effectMessages = {
      stun: `${target.card.name} is stunned and cannot act!`,
      sleep: `${target.card.name} falls asleep!`,
      poison: `${target.card.name} is poisoned!`,
      weaken: `${target.card.name} is weakened!`
    };
    
    if(effectMessages[effect]) {
      addLog('system', effectMessages[effect]);
    }
  }

  function processStatusEffects(side) {
    const slots = side === 'player' ? playerSlots : computerSlots;
    const slotsEl = side === 'player' ? playerSlotsEl : computerSlotsEl;
    
    slots.forEach((slot, idx) => {
      if(!slot || !slot.statusEffects) return;
      
      slot.statusEffects = slot.statusEffects.filter(effect => {
        effect.turnsRemaining--;
        
        if(effect.type === 'poison' && effect.turnsRemaining >= 0) {
          const poisonDmg = 5;
          slot.hp = Math.max(0, slot.hp - poisonDmg);
          addLog('system', `${slot.card.name} takes ${poisonDmg} poison damage`);
          
          const slotEl = slotsEl.children[idx];
          if(slotEl) {
            showDamagePopup(slotEl, poisonDmg, '#8B4513');
          }
        }
        
        if(effect.turnsRemaining <= 0) {
          const expiredMessages = {
            stun: `${slot.card.name} is no longer stunned!`,
            sleep: `${slot.card.name} wakes up!`,
            poison: `${slot.card.name} is no longer poisoned!`,
            weaken: `${slot.card.name} is no longer weakened!`
          };
          
          if(expiredMessages[effect.type]) {
            addLog('system', expiredMessages[effect.type]);
          }
          
          return false;
        }
        
        return true;
      });
      
      if(slot.hp <= 0) {
        slots[idx] = null;
      } else {
        updateSlotUI(side, idx);
      }
    });
    
    renderAll();
  }

  function hasStatusEffect(slot, effectType) {
    if(!slot || !slot.statusEffects) return false;
    return slot.statusEffects.some(effect => effect.type === effectType && effect.turnsRemaining > 0);
  }

  function createFlyingProjectile(fromElement, toElement, callback, damage) {
    const projectile = fromElement.cloneNode(true);
    projectile.style.position = 'fixed';
    projectile.style.pointerEvents = 'none';
    projectile.style.zIndex = '2000';
    
    const fromRect = fromElement.getBoundingClientRect();
    const toRect = toElement.getBoundingClientRect();
    
    const deltaX = toRect.left - fromRect.left;
    const deltaY = toRect.top - fromRect.top;
    
    projectile.style.left = fromRect.left + 'px';
    projectile.style.top = fromRect.top + 'px';
    
    document.body.appendChild(projectile);
    
    projectile.style.setProperty('--target-x', deltaX + 'px');
    projectile.style.setProperty('--target-y', deltaY + 'px');
    
    projectile.classList.add('flying-attack');
    
    setTimeout(() => {
      projectile.remove();
      if(callback) callback(damage);
    }, 800);
  }

  function renderAll(){
    for(let i=0;i<MAX_SLOTS;i++){
      const pSlotEl = playerSlotsEl.children[i];
      pSlotEl.innerHTML = ''; pSlotEl.classList.remove('occupied');
      if(playerSlots[i]){
        pSlotEl.classList.add('occupied');
        pSlotEl.appendChild(makeBattleCardEl(playerSlots[i], 'player', i));
      }
      const cSlotEl = computerSlotsEl.children[i];
      cSlotEl.innerHTML = ''; cSlotEl.classList.remove('occupied');
      if(computerSlots[i]){
        cSlotEl.classList.add('occupied');
        cSlotEl.appendChild(makeBattleCardEl(computerSlots[i], 'computer', i));
      }
    }
    renderHand();
    updateGlobalHPUI();
  }

  function makeBattleCardEl(slotObj, owner, slotIndex){
    const wrap = document.createElement('div'); 
    wrap.className = `card ${slotObj.used ? 'used' : ''}`;
    wrap.style.width='86px'; 
    wrap.style.height='120px';
    wrap.style.position = 'relative';
    
    const img = document.createElement('img'); 
    img.src = slotObj.card.src; 
    img.alt = slotObj.card.name;
    
    img.onerror = function() {
      const placeholder = document.createElement('div');
      placeholder.style.width = '100%';
      placeholder.style.height = '72%';
      placeholder.style.background = 'linear-gradient(45deg, #2D1B69, #11998E)';
      placeholder.style.display = 'flex';
      placeholder.style.alignItems = 'center';
      placeholder.style.justifyContent = 'center';
      placeholder.style.color = '#fff';
      placeholder.style.fontSize = '10px';
      placeholder.style.textAlign = 'center';
      placeholder.textContent = slotObj.card.name;
      this.parentNode.replaceChild(placeholder, this);
    };
    
    const stats = document.createElement('div'); 
    stats.className='stats';
    stats.innerHTML = `<div style="font-size:10px">${slotObj.card.name}</div><div class="card-hp" style="font-size:10px">HP: ${slotObj.hp}</div>`;
    
    wrap.appendChild(img); 
    wrap.appendChild(stats);
    
    if(slotObj.defending){
      wrap.style.boxShadow = '0 0 10px rgba(56,239,125,0.8)';
    }
    
    // STATUS EFFECT INDICATORS
    if(slotObj.statusEffects && slotObj.statusEffects.length > 0) {
      const statusContainer = document.createElement('div');
      statusContainer.className = 'status-effects-container';
      
      const activeEffects = {};
      slotObj.statusEffects.forEach(effect => {
        if(effect.turnsRemaining > 0) {
          activeEffects[effect.type] = effect;
        }
      });
      
      Object.values(activeEffects).forEach(effect => {
        const statusEl = document.createElement('div');
        statusEl.className = `status-effect ${effect.type}`;
        statusEl.title = `${effect.type.charAt(0).toUpperCase() + effect.type.slice(1)}: ${effect.turnsRemaining} turns remaining`;
        
        const turnsEl = document.createElement('div');
        turnsEl.className = 'status-turns';
        turnsEl.textContent = effect.turnsRemaining;
        statusEl.appendChild(turnsEl);
        
        statusContainer.appendChild(statusEl);
        
        if(effect.type === 'sleep') {
          for(let i = 1; i <= 3; i++) {
            const zzz = document.createElement('div');
            zzz.className = 'sleep-zzz';
            zzz.textContent = 'Z';
            zzz.style.animationDelay = `${(i-1) * 0.5}s`;
            wrap.appendChild(zzz);
          }
        }
      });
      
      wrap.appendChild(statusContainer);
    }
    
    wrap.dataset.owner = owner;
    wrap.dataset.slot = slotIndex;
    wrap._hpEl = stats.querySelector('.card-hp');

    return wrap;
  }

  function updateSlotUI(side, idx){
    const slot = (side==='player' ? playerSlots[idx] : computerSlots[idx]);
    const slotEl = (side==='player' ? playerSlotsEl : computerSlotsEl).children[idx];
    if(slot && slotEl.firstChild){
      slotEl.firstChild.querySelector('.card-hp').textContent = `HP: ${slot.hp}`;
    }
    updateGlobalHPUI();
  }

  function updateGlobalHPUI(){
    const sumPlayer = playerSlots.reduce((s,slot)=> s + (slot?slot.hp:0), 0);
    const sumComputer = computerSlots.reduce((s,slot)=> s + (slot?slot.hp:0), 0);
    playerGlobalHP.innerHTML = ''; 
    computerGlobalHP.innerHTML = '';
    const totalPossible = MAX_SLOTS * MAX_HP;
    const playerFrac = sumPlayer / totalPossible;
    const compFrac = sumComputer / totalPossible;
    renderSegments(playerGlobalHP, playerFrac);
    renderSegments(computerGlobalHP, compFrac);
  }

  function renderSegments(container, fraction){
    const segmentsToShow = fraction * SEGMENTS;
    for(let i=0;i<SEGMENTS;i++){
      const s = document.createElement('div'); s.className='seg';
      const remain = segmentsToShow - i;
      if(remain <= 0) { s.style.opacity = 0.12; }
      else if(remain < 1) { s.classList.add('half'); }
      container.appendChild(s);
    }
  }

  function checkBattleOver(){
    const playerHas = playerSlots.some(s=>s && s.hp>0);
    const compHas = computerSlots.some(s=>s && s.hp>0);
    if(!playerHas || !compHas){
      const result = compHas ? 'defeat' : 'victory';
      addLog('system', `Battle over: ${result.toUpperCase()}`);
      setTimeout(()=>showGameOver(result), 500);
    }
  }

  function showGameOver(result){
    alert(result==='victory' ? 'You won!' : 'You lost!');
  }

  endTurnBtn.addEventListener('click', ()=>{
    if(!playerTurn || endTurnBtn.classList.contains('disabled')) return;
    
    hideActionPanel();
    clearSelections();
    playerTurn = false;
    addLog('system','Player ended their turn.');
    
    if(!turnIndicator.textContent.includes('Setup')){
      setTimeout(()=>computerTurn(), 500);
    }
  });

  function computerInitialPlacement(){
    const emptySlots = [];
    for(let i = 0; i < MAX_SLOTS; i++){
      if(computerSlots[i] === null){
        emptySlots.push(i);
      }
    }
    
    const playerOccupiedSlots = playerSlots.map((slot, idx) => slot ? idx : -1).filter(idx => idx !== -1);
    const cardsToPlace = Math.min(Math.max(1, playerOccupiedSlots.length), 3, computerReserve.length);
    
    const prioritySlots = playerOccupiedSlots.filter(idx => emptySlots.includes(idx));
    const remainingSlots = emptySlots.filter(idx => !prioritySlots.includes(idx));
    
    const targetSlots = [...prioritySlots, ...remainingSlots].slice(0, cardsToPlace);
    
    targetSlots.forEach((slotIdx, i) => {
      if(i < computerReserve.length){
        const card = computerReserve[i];
        computerSlots[slotIdx] = { card, hp: MAX_HP, defending: false, used: false, statusEffects: [] };
      }
    });
    
    renderAll();
    addLog('system', `Computer placed ${targetSlots.length} cards strategically.`);
  }

  function computerPlaceCard(){
    const emptySlots = [];
    for(let i = 0; i < MAX_SLOTS; i++){
      if(computerSlots[i] === null){
        emptySlots.push(i);
      }
    }
    
    if(emptySlots.length === 0 || computerReserve.length === 0) return false;
    
    const placedCount = computerSlots.filter(slot => slot !== null).length;
    if(placedCount >= computerReserve.length) return false;
    
    const playerOccupiedSlots = playerSlots.map((slot, idx) => slot && slot.hp > 0 ? idx : -1).filter(idx => idx !== -1);
    const goodSlots = emptySlots.filter(idx => playerOccupiedSlots.includes(idx));
    const targetSlot = goodSlots.length > 0 ? goodSlots[Math.floor(Math.random() * goodSlots.length)] : 
                      emptySlots[Math.floor(Math.random() * emptySlots.length)];
    
    const cardToPlace = computerReserve[placedCount];
    computerSlots[targetSlot] = { card: cardToPlace, hp: MAX_HP, defending: false, used: false, statusEffects: [] };
    
    renderAll();
    addLog('computer', `Computer placed ${cardToPlace.name} in slot ${targetSlot + 1}`);
    return true;
  }

  function addLog(type, text){
    const div = document.createElement('div'); 
    div.className='entry ' + (type==='player'?'player':type==='computer'?'computer':'system'); 
    div.textContent = text;
    logEl.appendChild(div); 
    logEl.scrollTop = logEl.scrollHeight;
  }

  document.addEventListener('click', (e) => {
    if(currentActionPanel && !currentActionPanel.contains(e.target) && 
       !e.target.closest('.slot') && !e.target.closest('.card')){
      hideActionPanel();
      clearSelections();
    }
  });

  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape'){
      hideActionPanel();
      clearSelections();
    }
    if(e.key === ' ' || e.key === 'Enter'){
      if(playerTurn && !endTurnBtn.classList.contains('disabled')){
        endTurnBtn.click();
        e.preventDefault();
      }
    }
  });

  function decideFirstPlayer(){
    playerTurn = true;
    turnIndicator.textContent = 'Player Setup Phase';
    endTurnBtn.classList.add('disabled');
    addLog('system', 'Place your cards on the battlefield first.');
  }

  function checkBattleStart(){
    const playerHasCards = playerSlots.some(slot => slot !== null);

    if(playerHasCards && turnIndicator.textContent.includes('Setup')){
      addLog('system', 'Computer is ready to battle...');

      computerInitialPlacement();

      setTimeout(() => {
        turnIndicator.textContent = 'Player Turn'; // Force battle start
        addLog('system', 'Battle begins! Click your cards to see attack/defend options.');
        playerTurn = true;
        endTurnBtn.classList.remove('disabled');
      }, 1500);
    }
  }

  function init(){
    console.log("Initializing game...");
    makeSlotsUI();
    loadPlayerInventory();
    buildComputerReserve();
    renderAll();
    decideFirstPlayer();
    addLog('system', 'Place cards by clicking a hand card, then click an empty player slot.');
    addLog('system', 'The battle will begin once you place your first card.');
    console.log("Game initialized successfully!");
  }

  window._debug = { playerSlots, computerSlots, playerHand, computerReserve };

  init();

})();
</script>
</body>
</html>
